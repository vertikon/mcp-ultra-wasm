name: Continuous Deployment

on:
  workflow_run:
    workflows: ["Continuous Integration"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      version:
        description: 'Version to deploy'
        required: true
        default: 'latest'
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  packages: read
  deployments: write
  actions: read
  id-token: write

jobs:
  # Determine deployment strategy
  deployment-strategy:
    name: Determine Deployment Strategy
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.strategy.outputs.environment }}
      strategy: ${{ steps.strategy.outputs.strategy }}
      image_tag: ${{ steps.strategy.outputs.image_tag }}
      
    steps:
    - name: Determine deployment strategy
      id: strategy
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "strategy=blue-green" >> $GITHUB_OUTPUT
          else
            echo "strategy=canary" >> $GITHUB_OUTPUT
          fi
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "strategy=canary" >> $GITHUB_OUTPUT
          echo "image_tag=latest" >> $GITHUB_OUTPUT
        fi

  # Staging Deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: deployment-strategy
    if: needs.deployment-strategy.outputs.environment == 'staging'
    environment: 
      name: staging
      url: https://staging.mcp-ultra-wasm.example.com
    timeout-minutes: 20
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: mcp-ultra-wasm-deploy
        aws-region: us-east-1

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region us-east-1 --name mcp-ultra-wasm-staging

    # Pre-deployment validations
    - name: Validate cluster connectivity
      run: |
        kubectl cluster-info
        kubectl get nodes
        kubectl get namespaces

    - name: Validate image exists
      run: |
        docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.deployment-strategy.outputs.image_tag }}

    # Deploy configuration
    - name: Apply ConfigMaps and Secrets
      run: |
        kubectl apply -f deploy/k8s/namespace.yaml
        kubectl apply -f deploy/k8s/configmap.yaml
        kubectl apply -f deploy/k8s/secrets.yaml
      env:
        KUBE_NAMESPACE: mcp-ultra-wasm-staging

    # Database migrations
    - name: Run database migrations
      run: |
        kubectl create job --from=cronjob/migrate migrate-$(date +%s) -n mcp-ultra-wasm-staging || true
        kubectl wait --for=condition=complete --timeout=300s job/migrate-$(date +%s) -n mcp-ultra-wasm-staging

    # Canary deployment
    - name: Deploy Canary (10%)
      run: |
        sed 's/{{IMAGE_TAG}}/${{ needs.deployment-strategy.outputs.image_tag }}/g' deploy/k8s/deployment.yaml | kubectl apply -f -
        sed 's/{{CANARY_WEIGHT}}/10/g' deploy/flagger/canary.yaml | kubectl apply -f -

    # Wait for canary analysis
    - name: Monitor Canary Deployment
      run: |
        kubectl wait --for=condition=Promoted --timeout=600s canary/mcp-ultra-wasm -n mcp-ultra-wasm-staging
        echo "Canary deployment successful!"

    # Health checks
    - name: Perform health checks
      run: |
        kubectl get pods -n mcp-ultra-wasm-staging
        kubectl get services -n mcp-ultra-wasm-staging
        
        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/mcp-ultra-wasm -n mcp-ultra-wasm-staging
        
        # Test health endpoint
        STAGING_URL=$(kubectl get service mcp-ultra-wasm -n mcp-ultra-wasm-staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        curl -f "http://$STAGING_URL/health" || exit 1

    # Integration tests against staging
    - name: Run staging integration tests
      run: |
        export STAGING_URL=$(kubectl get service mcp-ultra-wasm -n mcp-ultra-wasm-staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        go test -v -tags=staging ./test/e2e/...
      env:
        TEST_ENDPOINT: staging

    - name: Deployment Success Notification
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: 'üöÄ MCP Ultra successfully deployed to staging!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Production Deployment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deployment-strategy
    if: needs.deployment-strategy.outputs.environment == 'production'
    environment: 
      name: production
      url: https://api.mcp-ultra-wasm.example.com
    timeout-minutes: 45
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PROD_ROLE_ARN }}
        role-session-name: mcp-ultra-wasm-prod-deploy
        aws-region: us-east-1

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region us-east-1 --name mcp-ultra-wasm-production

    # Enhanced pre-deployment validations for production
    - name: Validate production readiness
      run: |
        kubectl cluster-info
        kubectl get nodes
        
        # Check cluster resources
        kubectl top nodes
        kubectl get pods --all-namespaces | grep -v Running | head -10
        
        # Validate PVCs and storage
        kubectl get pvc -n mcp-ultra-wasm-production

    - name: Validate image security
      run: |
        # Additional security validation for production
        docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.deployment-strategy.outputs.image_tag }}
        echo "Image validation passed"

    # Backup current state
    - name: Backup current deployment
      run: |
        kubectl get deployment mcp-ultra-wasm -n mcp-ultra-wasm-production -o yaml > deployment-backup.yaml
        kubectl get configmap -n mcp-ultra-wasm-production -o yaml > configmap-backup.yaml
        
        # Upload backups to S3
        aws s3 cp deployment-backup.yaml s3://mcp-ultra-wasm-backups/deployments/$(date +%Y%m%d-%H%M%S)/
        aws s3 cp configmap-backup.yaml s3://mcp-ultra-wasm-backups/configs/$(date +%Y%m%d-%H%M%S)/

    # Blue-Green Deployment for Production
    - name: Prepare Green Environment
      run: |
        # Create green deployment
        sed 's/{{IMAGE_TAG}}/${{ needs.deployment-strategy.outputs.image_tag }}/g; s/mcp-ultra-wasm/mcp-ultra-wasm-green/g' deploy/k8s/deployment.yaml | kubectl apply -f -
        
        # Wait for green deployment to be ready
        kubectl wait --for=condition=available --timeout=600s deployment/mcp-ultra-wasm-green -n mcp-ultra-wasm-production
        
        echo "Green environment ready"

    # Production health checks
    - name: Health check Green environment
      run: |
        kubectl get pods -l app=mcp-ultra-wasm-green -n mcp-ultra-wasm-production
        
        # Port forward for testing
        kubectl port-forward deployment/mcp-ultra-wasm-green 8080:9655 -n mcp-ultra-wasm-production &
        PF_PID=$!
        sleep 10
        
        # Test health endpoints
        curl -f "http://localhost:8080/health" || exit 1
        curl -f "http://localhost:8080/metrics" || exit 1
        
        # Test gRPC endpoint
        grpcurl -plaintext localhost:9656 grpc.health.v1.Health/Check || echo "gRPC health check - configure as needed"
        
        kill $PF_PID

    # Database migrations with rollback capability
    - name: Run production migrations
      run: |
        # Create migration job with rollback tracking
        kubectl create job --from=cronjob/migrate migrate-prod-$(date +%s) -n mcp-ultra-wasm-production
        kubectl wait --for=condition=complete --timeout=600s job/migrate-prod-$(date +%s) -n mcp-ultra-wasm-production

    # Smoke tests on green environment
    - name: Run production smoke tests
      run: |
        kubectl port-forward deployment/mcp-ultra-wasm-green 8080:9655 -n mcp-ultra-wasm-production &
        PF_PID=$!
        sleep 10
        
        export TEST_ENDPOINT=http://localhost:8080
        go test -v -tags=smoke ./test/e2e/smoke_test.go
        
        kill $PF_PID

    # Traffic switch (Blue-Green)
    - name: Switch traffic to Green
      run: |
        # Update service selector to point to green deployment
        kubectl patch service mcp-ultra-wasm -n mcp-ultra-wasm-production -p '{"spec":{"selector":{"version":"green"}}}'
        
        # Verify traffic switch
        sleep 30
        PROD_URL=$(kubectl get service mcp-ultra-wasm -n mcp-ultra-wasm-production -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        curl -f "http://$PROD_URL/health" || exit 1
        
        echo "Traffic successfully switched to green deployment"

    # Monitor for a period before cleanup
    - name: Monitor production deployment
      run: |
        echo "Monitoring production deployment for 5 minutes..."
        sleep 300
        
        # Check for any issues
        kubectl get pods -l version=green -n mcp-ultra-wasm-production
        kubectl logs -l version=green --tail=100 -n mcp-ultra-wasm-production | grep ERROR || echo "No errors found"

    # Cleanup blue environment
    - name: Cleanup Blue environment
      run: |
        # Scale down blue deployment
        kubectl scale deployment mcp-ultra-wasm-blue --replicas=0 -n mcp-ultra-wasm-production || echo "Blue deployment not found"
        
        # Keep blue deployment for potential rollback (don't delete immediately)
        echo "Blue environment scaled down, kept for rollback if needed"

    - name: Production deployment success notification
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#production-deployments'
        text: 'üéâ MCP Ultra successfully deployed to PRODUCTION! Version: ${{ needs.deployment-strategy.outputs.image_tag }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Rollback capability
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure()
    environment: 
      name: ${{ needs.deployment-strategy.outputs.environment }}
    timeout-minutes: 15
    needs: [deployment-strategy, deploy-staging, deploy-production]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ needs.deployment-strategy.outputs.environment == 'production' && secrets.AWS_PROD_ROLE_ARN || secrets.AWS_ROLE_ARN }}
        role-session-name: mcp-ultra-wasm-rollback
        aws-region: us-east-1

    - name: Rollback deployment
      run: |
        ENVIRONMENT="${{ needs.deployment-strategy.outputs.environment }}"
        NAMESPACE="mcp-ultra-wasm-${ENVIRONMENT}"
        
        if [ "$ENVIRONMENT" = "production" ]; then
          # Blue-Green rollback - switch back to blue
          kubectl patch service mcp-ultra-wasm -n $NAMESPACE -p '{"spec":{"selector":{"version":"blue"}}}'
          kubectl scale deployment mcp-ultra-wasm-green --replicas=0 -n $NAMESPACE
          kubectl scale deployment mcp-ultra-wasm-blue --replicas=3 -n $NAMESPACE
          echo "Rolled back to blue deployment in production"
        else
          # Canary rollback
          kubectl rollout undo deployment/mcp-ultra-wasm -n $NAMESPACE
          echo "Rolled back deployment in staging"
        fi

    - name: Verify rollback
      run: |
        ENVIRONMENT="${{ needs.deployment-strategy.outputs.environment }}"
        NAMESPACE="mcp-ultra-wasm-${ENVIRONMENT}"
        
        kubectl wait --for=condition=available --timeout=300s deployment/mcp-ultra-wasm -n $NAMESPACE
        kubectl get pods -n $NAMESPACE

    - name: Rollback notification
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#alerts'
        text: '‚ö†Ô∏è MCP Ultra deployment failed and was rolled back in ${{ needs.deployment-strategy.outputs.environment }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Post-deployment validation
  post-deployment-validation:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: [deployment-strategy, deploy-staging, deploy-production]
    if: success()
    timeout-minutes: 15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ needs.deployment-strategy.outputs.environment == 'production' && secrets.AWS_PROD_ROLE_ARN || secrets.AWS_ROLE_ARN }}
        role-session-name: mcp-ultra-wasm-validation
        aws-region: us-east-1

    # Comprehensive post-deployment tests
    - name: Validate deployment health
      run: |
        ENVIRONMENT="${{ needs.deployment-strategy.outputs.environment }}"
        NAMESPACE="mcp-ultra-wasm-${ENVIRONMENT}"
        
        # Check all pods are running
        kubectl get pods -n $NAMESPACE
        
        # Check services are accessible
        kubectl get services -n $NAMESPACE
        
        # Check ingress is configured
        kubectl get ingress -n $NAMESPACE

    # Performance validation
    - name: Performance validation
      run: |
        ENVIRONMENT="${{ needs.deployment-strategy.outputs.environment }}"
        
        # Basic load test to ensure performance hasn't degraded
        if [ "$ENVIRONMENT" = "staging" ]; then
          echo "Running performance validation on staging"
          go test -v -tags=performance ./test/performance/... -timeout=10m
        fi

    # Security validation
    - name: Security validation
      run: |
        ENVIRONMENT="${{ needs.deployment-strategy.outputs.environment }}"
        NAMESPACE="mcp-ultra-wasm-${ENVIRONMENT}"
        
        # Check security policies are applied
        kubectl get networkpolicies -n $NAMESPACE
        kubectl get podsecuritypolicy -n $NAMESPACE || echo "PodSecurityPolicy not found (may be using Pod Security Standards)"

    - name: Deployment validation complete
      run: |
        echo "‚úÖ All post-deployment validations passed!"
        echo "Environment: ${{ needs.deployment-strategy.outputs.environment }}"
        echo "Image: ${{ needs.deployment-strategy.outputs.image_tag }}"
        echo "Strategy: ${{ needs.deployment-strategy.outputs.strategy }}"